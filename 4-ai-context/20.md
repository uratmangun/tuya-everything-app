# Chat Conversation - Session 20

Note: _This is purely the output of the chat conversation and does not contain any raw data, codebase snippets, etc. used to generate the output._

## Summary

Investigated and fixed UDP audio stream cutoff issues, then rewrote the webapp server from Node.js to Go for better reliability.

---

## Problem

The UDP microphone stream from DevKit to the webapp was experiencing frequent cutoffs. The stream would stop unexpectedly even when the DevKit was continuously sending UDP packets.

## Root Cause Analysis

After analyzing server logs, identified multiple issues:

1. **WebSocket instability** - WS connections kept disconnecting/reconnecting frequently
2. **Audio stream tied to WS lifecycle** - When WS reconnected, the audio HTTP stream would restart
3. **Multiple audio clients** - Duplicate stream connections were being created (logs showed "total: 2")
4. **UDP packets lost during reconnection** - When no audio clients connected, incoming UDP packets were discarded

## Initial Fixes (Node.js)

1. Added WebSocket ping/pong keepalive (30 second interval) to prevent disconnections
2. Improved client-side audio stream management:
   - Better retry logic with exponential backoff
   - Max retry limit (10 retries)
   - Proper abort handling
   - Decoupled audio stream from WebSocket lifecycle
3. Increased audio buffer from 50ms to 150ms for smoother playback

## Go Server Rewrite

User suggested Node.js might not be reliable for UDP/TCP networking. Rewrote the entire server in Go for better performance:

### Go Server Features
- **TCP Server (port 5000)** - DevKit command connection with length-prefixed protocol
- **UDP Server (port 5001)** - Low-latency audio streaming with 1MB read buffer
- **HTTP + WebSocket (port 3000)** - Web UI on same port, WebSocket upgrades on root path
- **Session-based auth** - HMAC-signed cookies for web sessions
- **Token-based auth** - For WebSocket and TCP connections
- **Chunked HTTP streaming** - For audio data to browser clients

### Key Go Improvements
- Goroutines for concurrent TCP/UDP/HTTP handling
- Proper mutex locking for shared state
- Buffered channels (100 items) for audio broadcast
- WebSocket ping/pong keepalive
- Larger UDP buffer (1MB) for better packet handling

## Deployment

Deployed Go server to VPS using podman:

```bash
# Build
podman build -f Dockerfile -t tuya-webapp-go:latest .

# Run
podman run -d --name tuya-webapp \
  --network tunnel-net \
  --env-file .env \
  -p 3000:3000 \
  -p 5000:5000 \
  -p 5001:5001/udp \
  tuya-webapp-go:latest
```

## Cleanup

Removed all Node.js related files from webapp folder:
- `package.json`
- `bun.lock`
- `server.js`
- `rtsp_relay.js`
- `rtp_receiver.js`

Updated files:
- `Dockerfile` - Multi-stage Go build
- `docker-compose.yml` - Updated ports and removed NODE_ENV
- `.gitignore` - Go-specific ignores (binary, IDE files)

## Final webapp Structure

```
webapp/
├── public/
│   ├── index.html
│   ├── login.html
│   └── ble/
├── main.go
├── go.mod
├── go.sum
├── Dockerfile
├── docker-compose.yml
├── .gitignore
├── .env.example
└── .env.production
```

## Result

The Go server is working well with no UDP stream cutoffs observed. The DevKit connects via TCP, authenticates, and streams audio via UDP continuously without interruption.
