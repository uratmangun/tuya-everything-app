# Voice Message Recording & Playback Implementation

## Summary

Successfully implemented voice message recording from web browser and playback on T5AI DevKit speaker. The solution records audio in the browser, converts it to MP3 on the server, and streams it to the DevKit via TCP for playback.

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     WebM/Opus      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      MP3 chunks     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Web Browser   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚   Go Server     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚   T5AI DevKit   â”‚
â”‚                 â”‚   POST /api/       â”‚   (VPS)         â”‚   TCP Protocol      â”‚                 â”‚
â”‚  MediaRecorder  â”‚   voice-message    â”‚   FFmpeg        â”‚   voicestart:       â”‚  ai_audio_playerâ”‚
â”‚                 â”‚                    â”‚   conversion    â”‚   vd:<chunk>        â”‚  (MP3 decoder)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   voiceend          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Files Changed

### 1. Web Application (webapp/)

#### webapp/main.go
- Fixed variable names from `pcmData` to `mp3Data` to reflect actual format
- FFmpeg converts WebM/Opus to MP3 (16kHz mono, 64kbps, 3x volume boost)
- Sends MP3 data in 1KB chunks via TCP protocol

**Key code - FFmpeg conversion:**
```go
cmd := exec.Command("ffmpeg",
    "-i", "pipe:0",     // Read from stdin
    "-f", "mp3",        // Output MP3 format
    "-ar", "16000",     // 16kHz sample rate
    "-ac", "1",         // Mono
    "-b:a", "64k",      // 64kbps bitrate
    "-af", "volume=3",  // 3x volume boost
    "pipe:1",           // Output to stdout
)
```

**Key code - TCP chunked protocol:**
```go
// 1. Send start marker with total length
startMsg := fmt.Sprintf("voicestart:%d", len(mp3Data))
sendMsg([]byte(startMsg))

// 2. Send MP3 data in 1KB chunks
const chunkSize = 1024
for i := 0; i < len(mp3Data); i += chunkSize {
    chunk := mp3Data[i:end]
    msg := append([]byte("vd:"), chunk...)
    sendMsg(msg)
}

// 3. Send end marker
sendMsg([]byte("voiceend"))
```

#### webapp/public/index.html
- Single "Record Voice" button (toggle start/stop)
- Uses MediaRecorder API to capture audio
- Sends recorded audio blob to `/api/voice-message` endpoint

**Key code - Recording UI:**
```html
<button id="recordVoiceBtn" onclick="toggleVoiceRecording()" class="btn btn-voice">
    ğŸ¤ Record Voice
</button>
```

**Key code - JavaScript:**
```javascript
let voiceRecorder = null;
let isRecording = false;

async function toggleVoiceRecording() {
    if (isRecording) {
        stopVoiceRecording();
    } else {
        startVoiceRecording();
    }
}

async function startVoiceRecording() {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    voiceRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
    
    voiceRecorder.ondataavailable = (e) => chunks.push(e.data);
    voiceRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm;codecs=opus' });
        await sendVoiceMessage(blob);
    };
    
    voiceRecorder.start();
    isRecording = true;
}

async function sendVoiceMessage(blob) {
    const response = await fetch('/api/voice-message', {
        method: 'POST',
        headers: { 'Content-Type': 'audio/webm;codecs=opus' },
        body: blob
    });
}
```

#### webapp/Dockerfile
- Added FFmpeg installation for audio conversion

```dockerfile
RUN apk add --no-cache ca-certificates ffmpeg
```

### 2. DevKit Firmware (apps/tuya_cloud/object_detection/src/)

#### tuya_main.c
- Updated comments to reflect MP3 format (not PCM)
- Voice streaming uses `ai_audio_player` which decodes MP3

**Key code - Voice command handlers:**
```c
else if (strncmp(data, "voicestart:", 11) == 0) {
    /* Start of voice message (MP3 format): "voicestart:<total_length>" */
    int total_len = atoi(data + 11);
    PR_INFO("[VOICE] Starting MP3 stream playback (%d bytes expected)", total_len);
    
    /* Stop any playing audio first */
    if (ai_audio_player_is_playing()) {
        ai_audio_player_stop();
        tal_system_sleep(50);
    }
    
    /* Start audio player for streaming MP3 */
    ai_audio_player_start("voice_stream");
    g_voice_expected_len = total_len;
    g_voice_received_len = 0;
    
    tcp_client_send_str("ok:voice_streaming");
}
else if (strncmp(data, "vd:", 3) == 0) {
    /* Voice data chunk: "vd:" + binary MP3 data - stream to audio player */
    int chunk_len = len - 3;
    const uint8_t *chunk_data = (const uint8_t *)(data + 3);
    
    if (chunk_len > 0) {
        /* Stream this MP3 chunk to audio player */
        ai_audio_player_data_write("voice_stream", (uint8_t *)chunk_data, chunk_len, 0);
        g_voice_received_len += chunk_len;
    }
}
else if (strncmp(data, "voiceend", 8) == 0) {
    /* End of voice message - signal end of stream */
    PR_INFO("[VOICE] Stream complete: %d bytes played", g_voice_received_len);
    
    /* Write empty buffer with is_end=1 to signal completion */
    ai_audio_player_data_write("voice_stream", NULL, 0, 1);
    
    tcp_client_send_str("ok:voice_done");
}
```

## Protocol Flow

```
Browser                    Server                     DevKit
   â”‚                          â”‚                          â”‚
   â”‚  POST /api/voice-message â”‚                          â”‚
   â”‚  (WebM/Opus blob)        â”‚                          â”‚
   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                          â”‚
   â”‚                          â”‚                          â”‚
   â”‚                    FFmpeg converts                  â”‚
   â”‚                    WebM â†’ MP3                       â”‚
   â”‚                          â”‚                          â”‚
   â”‚                          â”‚  TCP: voicestart:12345   â”‚
   â”‚                          â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
   â”‚                          â”‚                          â”‚
   â”‚                          â”‚  TCP: ok:voice_streaming â”‚
   â”‚                          â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚                          â”‚                          â”‚
   â”‚                          â”‚  TCP: vd:<1KB MP3 chunk> â”‚
   â”‚                          â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
   â”‚                          â”‚         (repeat)         â”‚
   â”‚                          â”‚                          â”‚
   â”‚                          â”‚  TCP: voiceend           â”‚
   â”‚                          â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
   â”‚                          â”‚                          â”‚
   â”‚                          â”‚  TCP: ok:voice_done      â”‚
   â”‚                          â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚                          â”‚                          â”‚
   â”‚  200 OK                  â”‚                          â”‚
   â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
   â”‚                          â”‚                          â”‚
```

## Key Insights

### Why MP3 instead of raw PCM?
- The DevKit's `ai_audio_player` module expects **encoded audio** (MP3/AAC)
- This is the same format used by `alert_audio_data.c` (hardcoded MP3 bytes)
- Raw PCM would require using `tdl_audio_play()` with a different audio handle

### Why chunked protocol?
- DevKit has limited TCP buffer (~2KB)
- Sending large audio files at once would overflow the buffer
- 1KB chunks fit comfortably and allow streaming playback

### FFmpeg settings explained:
- `-f mp3`: Output MP3 format (compatible with ai_audio_player)
- `-ar 16000`: 16kHz sample rate (DevKit speaker native rate)
- `-ac 1`: Mono (single speaker)
- `-b:a 64k`: 64kbps bitrate (good quality, small size)
- `-af volume=3`: 3x volume boost (browser audio is often quiet)

## Deployment Commands

### Build and Flash DevKit:
```fish
cd /home/uratmangun/CascadeProjects/TuyaOpen/apps/tuya_cloud/object_detection
fish -c "source build_with_env.fish; and ../../../tos.py build"
../../../tos.py flash -p /dev/ttyACM0
```

### Deploy Web App to VPS:
```fish
cd /home/uratmangun/CascadeProjects/TuyaOpen/webapp
rsync -avz --exclude='.git' . ubuntu@YOUR_TAILSCALE_IP:~/tuya-webapp/

ssh ubuntu@YOUR_TAILSCALE_IP "
  podman stop tuya-webapp-go 2>/dev/null
  podman rm tuya-webapp-go 2>/dev/null
  cd ~/tuya-webapp
  podman build -t tuya-webapp-go:latest .
  podman run -d --name tuya-webapp-go --network host \
    -e AUTH_USERNAME=admin \
    -e AUTH_PASSWORD=YOUR_AUTH_PASSWORD \
    -e AUTH_TOKEN=YOUR_AUTH_TOKEN \
    -e HTTP_PORT=3000 \
    -e TCP_PORT=5000 \
    -e UDP_PORT=5001 \
    tuya-webapp-go:latest
"
```

## Testing

1. Open web UI at `https://your-domain.com`
2. Click "ğŸ¤ Record Voice" button
3. Speak into microphone
4. Click "â¹ Stop Recording" button
5. Audio is sent to server, converted to MP3, and played on DevKit speaker

## Related Files

| File | Purpose |
|------|---------|
| `webapp/main.go` | Go server with FFmpeg conversion and TCP protocol |
| `webapp/public/index.html` | Web UI with MediaRecorder |
| `webapp/Dockerfile` | Container with FFmpeg |
| `apps/tuya_cloud/object_detection/src/tuya_main.c` | DevKit command handlers |
| `apps/tuya_cloud/object_detection/src/alert_audio_data.c` | Reference MP3 format |
