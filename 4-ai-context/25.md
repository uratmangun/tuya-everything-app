# Session 25 - December 20, 2025

## Summary

Continued work on T5AI DevKit audio streaming system. Implemented WebRTC with Opus encoding, fixed multiple issues with TCP protocol, WebSocket, and audio streaming.

---

## Issues Fixed

### 1. Login Page Redirect Loop

**Problem**: The login page at `bell.uratmangun.ovh` was reloading non-stop.

**Cause**: `/api/check-auth` returned HTTP 200 OK even when not authenticated. The login page checked `res.ok` which was true, causing redirect to `/` which redirected back to login.

**Fix** (`webapp/main.go`):
```go
func handleCheckAuth(w http.ResponseWriter, r *http.Request) {
    // Return 401 when not authenticated
    if !authenticated {
        w.WriteHeader(http.StatusUnauthorized)
    }
    json.NewEncoder(w).Encode(map[string]bool{"authenticated": authenticated})
}
```

---

### 2. TCP Protocol Mismatch

**Problem**: DevKit kept reconnecting with "Invalid message length" errors.

**Cause**: DevKit uses length-prefixed protocol `[4-byte length][message]`, but Go server was sending plain text for auth responses.

**Error logs showed**:
```
TCP recv header: len=4, bytes: 65 72 72 6F  ("erro")
Invalid message length: 1869771365
```
The server was sending `error:auth_required\n` as plain text.

**Fix** (`webapp/main.go`):
- Added `readLengthPrefixed()` helper to read length-prefixed messages
- Added `sendLengthPrefixed()` helper to send length-prefixed messages
- Updated auth handling and main receive loop to use length-prefixed protocol

---

### 3. WebSocket Status Always "Disconnected"

**Problem**: WebSocket showed disconnected even though commands worked.

**Cause**: Server didn't send `auth_success` message after authentication.

**Fix** (`webapp/main.go`):
```go
if client.authenticated {
    sendWSMessage(client, map[string]interface{}{
        "type": "auth_success",
        "devkit": map[string]interface{}{
            "connected": devkitConnected,
        },
        "serverIP": getLocalIP(),
        "tcpPort":  tcpPort,
    })
}
```

---

### 4. WebSocket Disconnecting Every ~100 Seconds

**Problem**: WebSocket kept disconnecting due to Cloudflare Tunnel idle timeout.

**Fix**: Added keepalive ping every 30 seconds.

**Client** (`webapp/public/index.html`):
```javascript
ws.onopen = () => {
    wsPingInterval = setInterval(() => {
        ws.send(JSON.stringify({ type: 'ping' }));
    }, 30000);
};
```

**Server** (`webapp/main.go`):
```go
case "ping":
    sendWSMessage(client, map[string]interface{}{
        "type": "pong",
    })
```

---

### 5. WebRTC Connection Failing

**Problem**: WebRTC kept showing "Connection state: failed" - ICE negotiation failing through Cloudflare Tunnel.

**Cause**: Only using STUN servers which don't relay traffic. Cloudflare Tunnel doesn't support direct UDP.

**Solution**: Set up self-hosted TURN server on VPS.

**TURN Server Setup**:
```bash
podman run -d --network=host --name=coturn \
  docker.io/instrumentisto/coturn \
  -n --log-file=stdout \
  --external-ip=YOUR_VPS_IP \
  --listening-port=3478 \
  --min-port=49152 --max-port=65535 \
  --realm=bell.uratmangun.ovh \
  --user=turnuser:TuyaT5DevKit2024
```

**Updated ICE config** (both server and client):
```javascript
iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    {
        urls: 'turn:YOUR_VPS_IP:3478',
        username: 'turnuser',
        credential: 'TuyaT5DevKit2024'
    }
]
```

**Required Firewall Ports** (AWS Lightsail):
- UDP/TCP 3478 (TURN signaling)
- UDP 49152-65535 (media relay)

---

### 6. Container Network Issue with WebRTC

**Problem**: WebRTC still failing even with TURN server.

**Cause**: Container on `tunnel-net` couldn't properly reach TURN server.

**Fix**: Run webapp container with `--network=host`:
```bash
podman run -d --name tuya-webapp-go \
  --network=host \
  -e AUTH_USERNAME=admin \
  ...
```

**Cloudflare Tunnel Update**: Changed URL from `tuya-webapp:3000` to `localhost:3000`.

---

## Optimizations Implemented

### 7. Buffer Bloat Protection (Device Side)

**Problem**: If WiFi hiccups, ring buffer fills with old audio causing 1+ minute latency.

**Fix** (`mic_streaming.c`):
```c
/* If buffer has more than 200ms of audio, drop old data */
const uint32_t MAX_BUFFER_BYTES = 6400;  // 200ms

if (data_len > MAX_BUFFER_BYTES) {
    PR_WARN("Buffer bloat! Dropping %u bytes to catch up", to_drop);
    while (tuya_ring_buff_used_size_get(g_mic_ctx.ringbuf) > MIC_FRAME_SIZE_PCM) {
        tuya_ring_buff_read(g_mic_ctx.ringbuf, pcm_buffer, MIC_FRAME_SIZE_PCM);
        drop_count++;
    }
}
```

---

### 8. Jitter Buffer + Pacer (Server Side)

**Problem**: UDP packets arrive in bursts causing choppy audio.

**Fix** (`webapp/main.go`):

**Jitter Buffer**:
```go
var jitterBuffer = make(chan []int16, 50)  // 50 frames (~1 second)
```

**UDP Server** (producer - non-blocking):
```go
select {
case jitterBuffer <- pcmFrame:
    // Queued
default:
    // Buffer full - drop to maintain real-time
    jitterDropCount++
}
```

**Pacer** (consumer - steady 20ms):
```go
func startPacer() {
    ticker := time.NewTicker(20 * time.Millisecond)
    for range ticker.C {
        select {
        case pcmData := <-jitterBuffer:
            opusData, _ := encodePCMToOpus(pcmData)
            writeAudioToTrack(opusData)
        default:
            // Empty - let browser PLC handle
        }
    }
}
```

---

## Documentation Created

### `/plan/pcm.md`
Complete documentation of PCM audio streaming:
- Device-side: mic capture → ring buffer → UDP send
- Server-side: UDP receive → Opus encode → WebRTC
- Packet format, data flow, latency breakdown

### `/plan/websocket.md`
Complete documentation of WebSocket communication:
- Message types and formats
- Authentication flow
- Keepalive mechanism
- Command routing to DevKit

---

## Current Issue Identified

### Mic Callback Not Being Called Consistently

**Symptoms** (from monitor.log):
```
[ONBOARD_MIC] data_size: 256000(Bytes), 62KB/s  ← Hardware captures
Mic stream heartbeat: sends=0, captured=0 bytes  ← But callback not called
```

The mic hardware captures 62KB/s, but `mic_audio_frame_callback` is only called intermittently. This is a platform-specific driver issue where the callback stops being invoked even though the hardware is capturing.

**Analysis**:
- Callback IS registered via `tdl_audio_open(audio_hdl, mic_cb)`
- Works briefly, then stops
- Hardware continues capturing (shown in stats)
- Likely needs audio subsystem to be "active" (e.g., during playback)

---

## Files Modified

### Firmware (`apps/tuya_cloud/object_detection/src/`)
| File | Changes |
|------|---------|
| `mic_streaming.c` | Added buffer bloat protection (drop old audio if >200ms) |

### Webapp (`webapp/`)
| File | Changes |
|------|---------|
| `main.go` | Fixed TCP length-prefixed protocol, added WS auth_success, added WS ping/pong, added jitter buffer + pacer, added ICE logging |
| `public/index.html` | Added WS keepalive ping, added ICE candidate logging, updated TURN server config |

---

## Deployment Commands Used

### Build & Flash Firmware
```bash
cd apps/tuya_cloud/object_detection
../../../tos.py build
../../../tos.py flash -p /dev/ttyACM0
```

### Deploy Webapp
```bash
ssh ubuntu@YOUR_TAILSCALE_IP "podman stop tuya-webapp-go; podman rm tuya-webapp-go"
scp -r webapp ubuntu@YOUR_TAILSCALE_IP:/tmp/webapp-deploy
ssh ubuntu@YOUR_TAILSCALE_IP "cd /tmp/webapp-deploy && podman build -t tuya-webapp-go:latest ."
ssh ubuntu@YOUR_TAILSCALE_IP "podman run -d --name tuya-webapp-go \
  --network=host \
  -e AUTH_USERNAME=admin \
  -e AUTH_PASSWORD=YOUR_AUTH_PASSWORD \
  -e AUTH_TOKEN=YOUR_AUTH_TOKEN \
  -e HTTP_PORT=3000 \
  -e TCP_PORT=5000 \
  -e UDP_PORT=5001 \
  --restart unless-stopped \
  tuya-webapp-go:latest"
```

---

## Architecture Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ T5AI DevKit                                                                 │
│  Mic → Ring Buffer → UDP [SEQ][PCM:640] ──────────────────────────────────┐ │
│                                                                            │ │
│  TCP Client ◄──────────────────────────────────────────────────────────┐  │ │
└────────────────────────────────────────────────────────────────────────│──│─┘
                                                                         │  │
                                                                    TCP  │  │ UDP
                                                                         │  │
┌────────────────────────────────────────────────────────────────────────│──│─┐
│ VPS (YOUR_VPS_IP)                                                    │  │ │
│                                                                        │  │ │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐    │  │ │
│  │ TCP Server:5000 │◄───┘                 │    │ UDP Server:5001 │◄───┘  │ │
│  │ (Commands)      │                      │    │ (Jitter Buffer) │       │ │
│  └────────┬────────┘                      │    └────────┬────────┘       │ │
│           │                               │             │                │ │
│           ▼                               │             ▼                │ │
│  ┌─────────────────┐                      │    ┌─────────────────┐       │ │
│  │ WebSocket       │◄─────────────────────┼────│ Pacer (20ms)    │       │ │
│  │ (Status/Cmds)   │                      │    │ Opus Encoder    │       │ │
│  └────────┬────────┘                      │    └────────┬────────┘       │ │
│           │                               │             │                │ │
│           │ Cloudflare Tunnel             │             │ WebRTC         │ │
│           │ (wss://)                      │             │ (via TURN)     │ │
│           │                               │             │                │ │
│  ┌────────┴────────┐                      │    ┌────────┴────────┐       │ │
│  │ TURN Server     │                      │    │ TURN Server     │       │ │
│  │ :3478           │◄─────────────────────┴────│ :3478           │       │ │
│  └─────────────────┘                           └─────────────────┘       │ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ HTTPS + WSS + WebRTC
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Browser (bell.uratmangun.ovh)                                               │
│  WebSocket (commands) + WebRTC (Opus audio)                                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Next Steps

1. **Investigate mic callback issue** - Why does `mic_audio_frame_callback` stop being called?
2. **Consider G.711 encoding on device** - Reduce bandwidth from 256kbps to 128kbps
3. **Add audio playback trigger** - May need to keep audio subsystem "active" for mic callback to work consistently
