# Session 18: UDP Audio Streaming for Low Latency

## Summary
Switched mic audio streaming from TCP to UDP for lower latency and more consistent audio playback. Also improved the web client audio handling with queue-based playback and auto-reconnect.

## Changes Made

### 1. Web Client Audio Improvements (index.html)
Before implementing UDP, improved the HTTP audio stream handling:
- Added audio queue system with `requestAnimationFrame` for smoother playback
- Auto-reconnect when stream disconnects
- Initial 100ms buffer to prevent gaps
- Smaller chunk size (640 bytes = 40ms) to match DevKit send rate

### 2. New UDP Audio Module (DevKit Firmware)

Created `udp_audio.h`:
```c
OPERATE_RET udp_audio_init(const char *host, uint16_t port);
OPERATE_RET udp_audio_send(const uint8_t *data, uint32_t len);
bool udp_audio_is_ready(void);
```

Created `udp_audio.c`:
- Creates UDP socket with `tal_net_socket_create(PROTOCOL_UDP)`
- Sends raw PCM data via `tal_net_send_to()`
- No connection overhead - fire and forget

### 3. Updated mic_streaming.c
- Changed from TCP to UDP transport
- Removed `audio:` prefix (not needed for UDP - dedicated port)
- Reduced send interval from 40ms to 20ms for lower latency
- Sends 1 frame (320 bytes) at a time instead of 2

Key changes:
```c
// Old (TCP)
#include "tcp_client.h"
tcp_client_send((const char *)send_buf, AUDIO_MSG_PREFIX_LEN + read_len);

// New (UDP)
#include "udp_audio.h"
udp_audio_send(send_buf, read_len);
```

### 4. Updated mic_streaming_start() signature
```c
// Old
OPERATE_RET mic_streaming_start(void);

// New - requires host and port for UDP
OPERATE_RET mic_streaming_start(const char *host, uint16_t port);
```

### 5. Updated tuya_main.c
- Added global `g_tcp_host[64]` variable for UDP to use same host as TCP
- Updated auto-start on auth:ok to pass host and UDP port 5001
- Updated "mic on" command to use UDP

```c
// Auto-start on connection
mic_streaming_start(g_tcp_host, 5001);
```

### 6. Updated Server (server.js)
Added UDP server alongside TCP:
```javascript
const dgram = require('dgram');
const UDP_PORT = process.env.UDP_PORT || 5001;

const udpServer = dgram.createSocket('udp4');
let udpPacketCount = 0;

udpServer.on('message', (msg, rinfo) => {
    udpPacketCount++;
    if (udpPacketCount % 50 === 1) {
        console.log(`[UDP] Received ${msg.length} bytes from ${rinfo.address}:${rinfo.port}`);
    }
    broadcastAudioToWeb(msg);
});

udpServer.bind(UDP_PORT, '0.0.0.0');
```

### 7. Updated Dockerfile
```dockerfile
EXPOSE 3000 5000 5001/udp
```

### 8. Updated Container Run Command
```bash
podman run -d \
  --name tuya-webapp \
  --network tunnel-net \
  --env-file .env.production \
  -p 3000:3000 \
  -p 5000:5000 \
  -p 5001:5001/udp \
  --restart unless-stopped \
  tuya-webapp:latest
```

## Architecture

```
DevKit (T5AI)                    VPS Server                      Web Browser
┌─────────────┐                 ┌─────────────┐                 ┌─────────────┐
│ Microphone  │                 │ TCP:5000    │                 │ Web Audio   │
│     ↓       │   TCP:5000      │ (commands)  │   HTTP:3000     │    API      │
│ Commands    │ ──────────────→ │             │ ──────────────→ │             │
│             │                 │             │  /audio-stream  │             │
│     ↓       │   UDP:5001      │ UDP:5001    │                 │             │
│ PCM Audio   │ ═══════════════>│ (audio)     │ ═══════════════>│ Playback    │
│ 8kHz 16-bit │  raw PCM        │     ↓       │  raw PCM chunks │             │
│ 320 bytes   │  no prefix      │ HTTP Stream │                 │             │
└─────────────┘                 └─────────────┘                 └─────────────┘
```

## Port Requirements

| Port | Protocol | Purpose |
|------|----------|---------|
| 3000 | TCP | HTTP + WebSocket (via Cloudflare tunnel) |
| 5000 | TCP | DevKit commands and control |
| 5001 | UDP | DevKit audio streaming |

## Firewall Configuration

**IMPORTANT**: UDP port 5001 must be open on your VPS firewall/security group.

For AWS EC2:
1. Go to AWS Console → EC2 → Security Groups
2. Edit inbound rules
3. Add: Custom UDP, Port 5001, Source 0.0.0.0/0

For UFW:
```bash
sudo ufw allow 5001/udp
```

For iptables:
```bash
sudo iptables -A INPUT -p udp --dport 5001 -j ACCEPT
```

## Files Modified

1. `/webapp/server.js` - Added UDP server
2. `/webapp/Dockerfile` - Exposed UDP port
3. `/webapp/public/index.html` - Improved audio queue and reconnect
4. `/apps/tuya_cloud/object_detection/src/udp_audio.h` - New file
5. `/apps/tuya_cloud/object_detection/src/udp_audio.c` - New file
6. `/apps/tuya_cloud/object_detection/src/mic_streaming.h` - Updated signature
7. `/apps/tuya_cloud/object_detection/src/mic_streaming.c` - Use UDP instead of TCP
8. `/apps/tuya_cloud/object_detection/src/tuya_main.c` - Global host, updated calls

## Deployment Commands

```bash
# Build and flash firmware
cd apps/tuya_cloud/object_detection
python3 ../../../tos.py build
python3 ../../../tos.py flash

# Deploy webapp
scp webapp/server.js webapp/Dockerfile webapp/package.json ubuntu@VPS:~/tuya-webapp/
scp -r webapp/public ubuntu@VPS:~/tuya-webapp/

# Rebuild container with UDP port
ssh ubuntu@VPS "cd ~/tuya-webapp && \
  podman build -t tuya-webapp:latest . && \
  podman stop tuya-webapp; podman rm tuya-webapp; \
  podman run -d --name tuya-webapp --network tunnel-net \
    --env-file .env.production \
    -p 3000:3000 -p 5000:5000 -p 5001:5001/udp \
    --restart unless-stopped tuya-webapp:latest"
```

## Benefits of UDP over TCP for Audio

1. **Lower latency** - No TCP handshake, no retransmission delays
2. **No head-of-line blocking** - Lost packets don't delay subsequent packets
3. **Simpler protocol** - No length prefix needed, dedicated port
4. **Better for real-time** - Acceptable to lose packets rather than delay

## Tradeoffs

1. **No guaranteed delivery** - Packets can be lost (acceptable for audio)
2. **Firewall issues** - UDP often blocked, need to open port
3. **No flow control** - Could overwhelm slow receivers

## Status

- ✅ Firmware built and flashed with UDP audio
- ✅ Server updated with UDP listener
- ✅ Container deployed with UDP port mapping
- ⏳ Waiting for AWS Security Group to allow UDP 5001
- ⏳ Testing audio quality after UDP enabled
