<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T5AI DevKit Configuration</title>
    <meta name="description" content="Configure your T5AI DevKit via Bluetooth - Set WiFi and TCP server settings">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚öôÔ∏è</text></svg>">
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111827;
            --bg-card: rgba(17, 24, 39, 0.8);
            --border-color: #1f2937;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --accent: #0ea5e9;
            --accent-hover: #0284c7;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bluetooth: #0082fc;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 16px;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 24px 0;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--accent) 0%, #22d3ee 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            backdrop-filter: blur(10px);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .card-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .card-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .card-icon.bluetooth {
            background: rgba(0, 130, 252, 0.15);
        }

        .card-icon.wifi {
            background: rgba(16, 185, 129, 0.15);
        }

        .card-icon.server {
            background: rgba(14, 165, 233, 0.15);
        }

        .card-icon.status {
            background: rgba(245, 158, 11, 0.15);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 10px;
            margin-bottom: 16px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--danger);
        }

        .status-dot.connected {
            background: var(--success);
        }

        .status-dot.connecting {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .status-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.2s ease;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(14, 165, 233, 0.3);
        }

        .btn-bluetooth {
            background: linear-gradient(135deg, var(--bluetooth) 0%, #0066cc 100%);
            color: white;
        }

        .btn-bluetooth:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 130, 252, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 14px 16px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.15);
        }

        .form-group input::placeholder {
            color: var(--text-muted);
        }

        .wifi-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 16px;
        }

        .wifi-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .wifi-item:hover {
            border-color: var(--border-color);
        }

        .wifi-item.selected {
            border-color: var(--accent);
            background: rgba(14, 165, 233, 0.1);
        }

        .wifi-item .ssid {
            font-weight: 500;
        }

        .wifi-item .signal {
            color: var(--text-muted);
            font-size: 14px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-muted);
            font-size: 14px;
        }

        .info-value {
            color: var(--text-primary);
            font-size: 14px;
            font-family: ui-monospace, monospace;
        }

        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
            transition: transform 0.3s ease;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--danger);
        }

        .hidden {
            display: none !important;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .section-divider {
            height: 1px;
            background: var(--border-color);
            margin: 20px 0;
        }

        .not-supported {
            text-align: center;
            padding: 40px;
        }

        .not-supported h2 {
            color: var(--danger);
            margin-bottom: 16px;
        }

        .not-supported p {
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .footer {
            text-align: center;
            padding: 24px;
            color: var(--text-muted);
            font-size: 12px;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .tab {
            flex: 1;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .tab:hover:not(.active) {
            border-color: var(--text-muted);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>‚öôÔ∏è T5AI Configuration</h1>
            <p>Configure your DevKit via Bluetooth</p>
        </div>

        <!-- Not Supported Message -->
        <div id="notSupported" class="card not-supported hidden">
            <h2>‚ùå Web Bluetooth Not Supported</h2>
            <p>Your browser doesn't support Web Bluetooth.</p>
            <p>Please use <strong>Chrome</strong>, <strong>Edge</strong>, or <strong>Opera</strong> on:</p>
            <p>‚Ä¢ Android, Windows, macOS, or Linux</p>
            <p style="margin-top: 16px; color: var(--text-muted);">
                Note: Safari (iPhone) does not support Web Bluetooth.
            </p>
        </div>

        <!-- Main Content -->
        <div id="mainContent">
            <!-- Bluetooth Connection Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-icon bluetooth">üì∂</div>
                    <h2>Bluetooth Connection</h2>
                </div>

                <div class="status-indicator">
                    <div class="status-dot" id="connectionDot"></div>
                    <span class="status-text" id="connectionStatus">Not Connected</span>
                </div>

                <button class="btn btn-bluetooth" id="connectBtn" onclick="connectDevice()">
                    <span>üîó</span> Connect to T5AI
                </button>

                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button class="btn" id="scanAllBtn" onclick="connectDeviceAll()"
                        style="flex: 1; background: var(--secondary); font-size: 12px; padding: 10px;">
                        <span>üì°</span> Scan All Devices
                    </button>
                    <button class="btn" id="reconnectBtn" onclick="reconnectDevice()"
                        style="flex: 1; background: var(--accent); font-size: 12px; padding: 10px;">
                        <span>üîÑ</span> Reconnect Last
                    </button>
                </div>

                <button class="btn btn-danger hidden" id="disconnectBtn" onclick="disconnectDevice()"
                    style="margin-top: 12px;">
                    <span>‚ùå</span> Disconnect
                </button>

                <div
                    style="margin-top: 16px; padding: 12px; background: rgba(245, 158, 11, 0.1); border-radius: 10px; font-size: 13px; color: var(--text-secondary);">
                    <strong>‚ö†Ô∏è Device not appearing?</strong><br>
                    ‚Ä¢ Device advertises as <strong>"TYBLE"</strong> or <strong>"BLE"</strong><br>
                    ‚Ä¢ BLE may be disabled when connected to WiFi/IoT cloud<br>
                    ‚Ä¢ Click <strong>"Scan All Devices"</strong> to see all nearby Bluetooth devices<br>
                    ‚Ä¢ Use <strong>"Reconnect Last"</strong> if you connected before<br>
                    ‚Ä¢ Or run <code
                        style="background: var(--bg-secondary); padding: 2px 6px; border-radius: 4px;">reset</code> in
                    CLI
                </div>
            </div>

            <!-- Configuration Tabs (only visible when connected) -->
            <div id="configSection" class="hidden">
                <div class="tabs">
                    <div class="tab active" data-tab="tcp" onclick="switchTab('tcp')">üåê TCP Server</div>
                    <div class="tab" data-tab="wifi" onclick="switchTab('wifi')">üì° WiFi</div>
                    <div class="tab" data-tab="status" onclick="switchTab('status')">üìä Status</div>
                </div>

                <!-- TCP Server Config -->
                <div class="card tab-content" id="tcpTab">
                    <div class="card-header">
                        <div class="card-icon server">üåê</div>
                        <h2>TCP Server Settings</h2>
                    </div>

                    <div class="form-group">
                        <label>Server Host</label>
                        <input type="text" id="tcpHost" placeholder="e.g., 192.168.1.100 or example.com">
                    </div>

                    <div class="form-group">
                        <label>Server Port</label>
                        <input type="number" id="tcpPort" placeholder="5000" value="5000" min="1" max="65535">
                    </div>

                    <div class="form-group">
                        <label>Auth Token</label>
                        <input type="text" id="tcpToken" placeholder="your-secret-token">
                    </div>

                    <button class="btn btn-primary" onclick="saveTcpSettings()">
                        <span>üíæ</span> Save TCP Settings
                    </button>
                </div>

                <!-- WiFi Config -->
                <div class="card tab-content hidden" id="wifiTab">
                    <div class="card-header">
                        <div class="card-icon wifi">üì°</div>
                        <h2>WiFi Configuration</h2>
                    </div>

                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-secondary" onclick="scanWifi()" id="scanWifiBtn" style="flex: 1;">
                            <span>üîç</span> Scan WiFi
                        </button>
                        <button class="btn btn-secondary" onclick="disconnectWifi()" id="disconnectWifiBtn" style="flex: 1; background: #dc3545;">
                            <span>üì¥</span> Disconnect WiFi
                        </button>
                    </div>

                    <div class="wifi-list" id="wifiList">
                        <div style="text-align: center; color: var(--text-muted); padding: 20px;">
                            Disconnect WiFi first, then scan for networks
                        </div>
                    </div>

                    <div class="section-divider"></div>

                    <div class="form-group">
                        <label>WiFi SSID</label>
                        <input type="text" id="wifiSsid" placeholder="Network name">
                    </div>

                    <div class="form-group">
                        <label>WiFi Password</label>
                        <input type="password" id="wifiPassword" placeholder="Enter password">
                    </div>

                    <button class="btn btn-primary" onclick="saveWifiSettings()">
                        <span>üì°</span> Connect to WiFi
                    </button>
                </div>

                <!-- Status Tab -->
                <div class="card tab-content hidden" id="statusTab">
                    <div class="card-header">
                        <div class="card-icon status">üìä</div>
                        <h2>Device Status</h2>
                    </div>

                    <button class="btn btn-secondary" onclick="refreshStatus()" style="margin-bottom: 16px;">
                        <span>üîÑ</span> Refresh Status
                    </button>

                    <div id="statusInfo">
                        <div class="info-row">
                            <span class="info-label">WiFi Status</span>
                            <span class="info-value" id="wifiStatus">--</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">WiFi SSID</span>
                            <span class="info-value" id="currentSsid">--</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">IP Address</span>
                            <span class="info-value" id="ipAddress">--</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">TCP Server</span>
                            <span class="info-value" id="tcpServerStatus">--</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Free Heap</span>
                            <span class="info-value" id="freeHeap">--</span>
                        </div>
                    </div>

                    <div class="section-divider"></div>

                    <h3 style="margin-bottom: 8px;">üì° BLE Log</h3>
                    <div id="bleLog" style="background: #1a1a2e; border-radius: 8px; padding: 12px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; color: #0f0;">
                        <div>Waiting for BLE data...</div>
                    </div>
                    <button class="btn btn-secondary" onclick="clearBleLog()" style="margin-top: 8px;">
                        <span>üóëÔ∏è</span> Clear Log
                    </button>

                    <div class="section-divider"></div>

                    <button class="btn btn-danger" onclick="rebootDevice()">
                        <span>üîÑ</span> Reboot Device
                    </button>
                </div>
            </div>
        </div>

        <div class="footer">
            T5AI DevKit ‚Ä¢ Web Bluetooth Configuration<br>
            Powered by TuyaOpen
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <span id="toastIcon">‚úÖ</span>
        <span id="toastMessage">Message</span>
    </div>

    <!-- Tuya BLE Crypto Library -->
    <script src="tuya-ble-crypto.js"></script>

    <script>
        // ===== Configuration =====
        // Tuya BLE Service UUIDs - Official Tuya registered UUIDs
        // The primary service is 0xFD50 (registered with Bluetooth SIG)
        const TUYA_SERVICE_UUID = '0000fd50-0000-1000-8000-00805f9b34fb';  // 0xFD50
        const TUYA_WRITE_UUID = '00000001-0000-1001-8001-00805f9b07d0';   // Write characteristic
        const TUYA_NOTIFY_UUID = '00000002-0000-1001-8001-00805f9b07d0';  // Notify characteristic

        // Alternative: Internal Tuya service (0xA201 - for some devices)
        const TUYA_INTERNAL_SERVICE_UUID = '0000a201-0000-1000-8000-00805f9b34fb';
        const TUYA_INTERNAL_WRITE_UUID = '0000a202-0000-1000-8000-00805f9b34fb';
        const TUYA_INTERNAL_NOTIFY_UUID = '0000a203-0000-1000-8000-00805f9b34fb';

        // Device credentials (from .env file)
        // These are needed for Tuya BLE encrypted communication
        const TUYA_UUID = 'uuid5449e77dcc3d02a9';
        const TUYA_AUTHKEY = 'U8nUH1sauV1VodzRPnaPE0mLFAGYkbbm';

        // ===== State =====
        let device = null;
        let server = null;
        let writeCharacteristic = null;
        let notifyCharacteristic = null;
        let currentTab = 'tcp';
        let tuyaCrypto = null;  // TuyaBLECrypto instance
        let receivedData = [];  // Buffer for received data

        // ===== Initialization =====
        document.addEventListener('DOMContentLoaded', () => {
            // Check Web Bluetooth support
            if (!navigator.bluetooth) {
                document.getElementById('notSupported').classList.remove('hidden');
                document.getElementById('mainContent').classList.add('hidden');
                return;
            }
        });

        // ===== Tab Switching =====
        function switchTab(tabName) {
            currentTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
            document.getElementById(`${tabName}Tab`).classList.remove('hidden');
        }

        // ===== Bluetooth Functions =====
        async function connectDevice() {
            const btn = document.getElementById('connectBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Scanning...';

            updateConnectionStatus('connecting');

            try {
                // Request device - accepts Tuya devices
                // Device may advertise as "TYBLE", "TY...", or just "BLE"
                device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'TY' },      // Tuya BLE name "TYBLE"
                        { namePrefix: 'tuya' },    // Lowercase variant
                        { namePrefix: 'T5' },      // T5AI prefix
                        { name: 'BLE' },           // Generic BLE name (some devices use this)
                    ],
                    optionalServices: [
                        TUYA_SERVICE_UUID,           // 0xFD50 official
                        TUYA_INTERNAL_SERVICE_UUID,  // 0xA201 internal
                    ],
                });

                console.log('Device selected:', device.name);

                // Connect to GATT server
                device.addEventListener('gattserverdisconnected', onDisconnected);
                server = await device.gatt.connect();

                console.log('Connected to GATT server');

                // Try to get service and characteristics
                // Try multiple service UUIDs in order: FD50 (official), A201 (internal)
                let serviceFound = false;

                // 1. Try official Tuya service (0xFD50)
                try {
                    console.log('Trying Tuya FD50 service...');
                    const service = await server.getPrimaryService(TUYA_SERVICE_UUID);
                    writeCharacteristic = await service.getCharacteristic(TUYA_WRITE_UUID);
                    notifyCharacteristic = await service.getCharacteristic(TUYA_NOTIFY_UUID);

                    await notifyCharacteristic.startNotifications();
                    notifyCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);

                    console.log('Tuya FD50 service connected!');
                    serviceFound = true;
                } catch (e) {
                    console.log('FD50 service not found:', e.message);
                }

                // 2. Try internal Tuya service (0xA201)
                if (!serviceFound) {
                    try {
                        console.log('Trying Tuya A201 service...');
                        const service = await server.getPrimaryService(TUYA_INTERNAL_SERVICE_UUID);
                        writeCharacteristic = await service.getCharacteristic(TUYA_INTERNAL_WRITE_UUID);
                        notifyCharacteristic = await service.getCharacteristic(TUYA_INTERNAL_NOTIFY_UUID);

                        await notifyCharacteristic.startNotifications();
                        notifyCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);

                        console.log('Tuya A201 service connected!');
                        serviceFound = true;
                    } catch (e) {
                        console.log('A201 service not found:', e.message);
                    }
                }

                // 3. List all available services
                if (!serviceFound) {
                    try {
                        console.log('Listing all services...');
                        const services = await server.getPrimaryServices();
                        console.log('Available services:', services.map(s => s.uuid));

                        // Try first available service with write characteristic
                        for (const service of services) {
                            try {
                                const chars = await service.getCharacteristics();
                                console.log('Service', service.uuid, 'characteristics:', chars.map(c => c.uuid));

                                // Look for a writable characteristic
                                for (const char of chars) {
                                    if (char.properties.write || char.properties.writeWithoutResponse) {
                                        writeCharacteristic = char;
                                        console.log('Found writable characteristic:', char.uuid);
                                    }
                                    if (char.properties.notify) {
                                        notifyCharacteristic = char;
                                        await char.startNotifications();
                                        char.addEventListener('characteristicvaluechanged', handleNotification);
                                        console.log('Found notify characteristic:', char.uuid);
                                    }
                                }
                                if (writeCharacteristic) {
                                    serviceFound = true;
                                    break;
                                }
                            } catch (e) {
                                console.log('Error reading service:', e.message);
                            }
                        }
                    } catch (e) {
                        console.log('Could not list services:', e.message);
                    }
                }

                // Initialize crypto if we found a service
                if (serviceFound) {
                    tuyaCrypto = new TuyaBLECrypto(TUYA_UUID, TUYA_AUTHKEY);
                    console.log('Tuya crypto initialized');
                    await sendDeviceInfoQuery();
                    showToast('‚úÖ', 'BLE service connected!', 'success');
                } else {
                    console.warn('No suitable BLE service found');
                    showToast('‚ö†Ô∏è', 'Connected but no BLE service found. Check console for available services.', 'error');
                }

                // Update UI
                updateConnectionStatus('connected');
                document.getElementById('configSection').classList.remove('hidden');
                btn.classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');

                showToast('‚úÖ', 'Connected to ' + device.name, 'success');

                // Request initial status after handshake
                setTimeout(() => refreshStatus(), 1500);

            } catch (error) {
                console.error('Connection error:', error);
                updateConnectionStatus('disconnected');

                // Provide helpful error messages
                if (error.name === 'NotFoundError') {
                    showToast('‚ö†Ô∏è', 'No devices found. Try "Scan All Devices" button.', 'error');
                } else {
                    showToast('‚ùå', 'Connection failed: ' + error.message, 'error');
                }
            }

            btn.disabled = false;
            btn.innerHTML = '<span>üîó</span> Connect to T5AI';
        }

        // Connect with no filters - shows ALL nearby Bluetooth devices
        async function connectDeviceAll() {
            const btn = document.getElementById('scanAllBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div>';

            updateConnectionStatus('connecting');

            try {
                // Request device - accepts ALL devices (no filtering)
                device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [TUYA_SERVICE_UUID, TUYA_INTERNAL_SERVICE_UUID],
                });

                console.log('Device selected:', device.name, '| ID:', device.id);

                // Connect to GATT server
                device.addEventListener('gattserverdisconnected', onDisconnected);
                server = await device.gatt.connect();

                console.log('Connected to GATT server');

                // Try to get Tuya service - try multiple UUIDs
                let serviceFound = false;

                // 1. Try FD50
                try {
                    console.log('Trying Tuya FD50 service...');
                    const service = await server.getPrimaryService(TUYA_SERVICE_UUID);
                    writeCharacteristic = await service.getCharacteristic(TUYA_WRITE_UUID);
                    notifyCharacteristic = await service.getCharacteristic(TUYA_NOTIFY_UUID);
                    await notifyCharacteristic.startNotifications();
                    notifyCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);
                    console.log('Tuya FD50 service connected!');
                    serviceFound = true;
                } catch (e) {
                    console.log('FD50 not found:', e.message);
                }

                // 2. Try A201
                if (!serviceFound) {
                    try {
                        console.log('Trying Tuya A201 service...');
                        const service = await server.getPrimaryService(TUYA_INTERNAL_SERVICE_UUID);
                        writeCharacteristic = await service.getCharacteristic(TUYA_INTERNAL_WRITE_UUID);
                        notifyCharacteristic = await service.getCharacteristic(TUYA_INTERNAL_NOTIFY_UUID);
                        await notifyCharacteristic.startNotifications();
                        notifyCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);
                        console.log('Tuya A201 service connected!');
                        serviceFound = true;
                    } catch (e) {
                        console.log('A201 not found:', e.message);
                    }
                }

                // 3. List and try all services
                if (!serviceFound) {
                    try {
                        const services = await server.getPrimaryServices();
                        console.log('Available services:', services.map(s => s.uuid));
                        for (const service of services) {
                            const chars = await service.getCharacteristics();
                            console.log('Service', service.uuid, ':', chars.map(c => c.uuid + '(' + Object.keys(c.properties).filter(k => c.properties[k]).join(',') + ')'));
                            for (const char of chars) {
                                if ((char.properties.write || char.properties.writeWithoutResponse) && !writeCharacteristic) {
                                    writeCharacteristic = char;
                                }
                                if (char.properties.notify && !notifyCharacteristic) {
                                    notifyCharacteristic = char;
                                    await char.startNotifications();
                                    char.addEventListener('characteristicvaluechanged', handleNotification);
                                }
                            }
                            if (writeCharacteristic) { serviceFound = true; break; }
                        }
                    } catch (e) {
                        console.log('Service enumeration failed:', e.message);
                    }
                }

                if (serviceFound) {
                    tuyaCrypto = new TuyaBLECrypto(TUYA_UUID, TUYA_AUTHKEY);
                    await sendDeviceInfoQuery();
                    showToast('‚úÖ', 'BLE service connected!', 'success');
                } else {
                    showToast('‚ö†Ô∏è', 'Connected but no writable characteristic found', 'error');
                }

                // Update UI
                updateConnectionStatus('connected');
                document.getElementById('configSection').classList.remove('hidden');
                document.getElementById('connectBtn').classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');

                showToast('‚úÖ', 'Connected to ' + device.name, 'success');

            } catch (error) {
                console.error('Connection error:', error);
                updateConnectionStatus('disconnected');
                showToast('‚ùå', error.message, 'error');
            }

            btn.disabled = false;
            btn.innerHTML = '<span>üì°</span> Scan All Devices';
        }

        // Try to reconnect to a previously paired device
        async function reconnectDevice() {
            const btn = document.getElementById('reconnectBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div>';

            updateConnectionStatus('connecting');

            try {
                // Check if getDevices is available (Chrome 85+)
                if (!navigator.bluetooth.getDevices) {
                    throw new Error('Reconnect not supported in this browser. Use Chrome 85+.');
                }

                // Get previously paired devices
                const devices = await navigator.bluetooth.getDevices();
                console.log('Previously paired devices:', devices.length);

                if (devices.length === 0) {
                    throw new Error('No previously paired devices. Connect first using scan.');
                }

                // Try to connect to the first available device
                let connected = false;
                for (const d of devices) {
                    console.log('Trying device:', d.name, d.id);

                    try {
                        // Watch for advertisements and connect
                        const abortController = new AbortController();

                        // Set timeout
                        setTimeout(() => abortController.abort(), 10000);

                        d.addEventListener('advertisementreceived', async (event) => {
                            console.log('Advertisement received from:', event.device.name);
                            abortController.abort();

                            device = event.device;
                            device.addEventListener('gattserverdisconnected', onDisconnected);
                            server = await device.gatt.connect();
                            connected = true;
                        });

                        await d.watchAdvertisements({ signal: abortController.signal }).catch(() => { });

                        if (connected) break;
                    } catch (e) {
                        console.log('Failed to reconnect to', d.name, ':', e.message);
                    }
                }

                if (!connected) {
                    // Try direct connection without watching
                    for (const d of devices) {
                        try {
                            device = d;
                            device.addEventListener('gattserverdisconnected', onDisconnected);
                            server = await device.gatt.connect();
                            connected = true;
                            break;
                        } catch (e) {
                            console.log('Direct connect failed for', d.name);
                        }
                    }
                }

                if (!connected) {
                    throw new Error('Could not reconnect. Device may be out of range.');
                }

                // Try to get Tuya service
                try {
                    const service = await server.getPrimaryService(TUYA_SERVICE_UUID);
                    writeCharacteristic = await service.getCharacteristic(TUYA_WRITE_UUID);
                    notifyCharacteristic = await service.getCharacteristic(TUYA_NOTIFY_UUID);

                    await notifyCharacteristic.startNotifications();
                    notifyCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);

                    tuyaCrypto = new TuyaBLECrypto(TUYA_UUID, TUYA_AUTHKEY);
                    await sendDeviceInfoQuery();
                } catch (e) {
                    console.log('Tuya service not found:', e.message);
                }

                // Update UI
                updateConnectionStatus('connected');
                document.getElementById('configSection').classList.remove('hidden');
                document.getElementById('connectBtn').classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');

                showToast('‚úÖ', 'Reconnected to ' + device.name, 'success');

            } catch (error) {
                console.error('Reconnect error:', error);
                updateConnectionStatus('disconnected');
                showToast('‚ö†Ô∏è', error.message, 'error');
            }

            btn.disabled = false;
            btn.innerHTML = '<span>üîÑ</span> Reconnect Last';
        }

        function disconnectDevice() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
        }

        function onDisconnected() {
            console.log('Device disconnected');
            updateConnectionStatus('disconnected');
            document.getElementById('configSection').classList.add('hidden');
            document.getElementById('connectBtn').classList.remove('hidden');
            document.getElementById('disconnectBtn').classList.add('hidden');

            device = null;
            server = null;
            writeCharacteristic = null;
            notifyCharacteristic = null;

            showToast('‚ö†Ô∏è', 'Device disconnected', 'error');
        }

        function updateConnectionStatus(status) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionStatus');

            dot.className = 'status-dot';

            switch (status) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = 'Connected to ' + (device?.name || 'Device');
                    break;
                case 'connecting':
                    dot.classList.add('connecting');
                    text.textContent = 'Connecting...';
                    break;
                default:
                    text.textContent = 'Not Connected';
            }
        }

        // ===== BLE Log =====
        function addBleLog(msg, type = 'info') {
            const log = document.getElementById('bleLog');
            const colors = { info: '#0f0', error: '#f55', warn: '#ff0', recv: '#0ff' };
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.style.color = colors[type] || '#0f0';
            div.textContent = `[${time}] ${msg}`;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
        }

        function clearBleLog() {
            document.getElementById('bleLog').innerHTML = '<div>Log cleared</div>';
        }

        // ===== Data Handling =====
        async function handleNotification(event) {
            const value = event.target.value;
            const data = new Uint8Array(value.buffer);

            const hexStr = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
            console.log('Received raw:', hexStr);
            addBleLog(`RX (${data.length} bytes): ${hexStr.substring(0, 60)}...`, 'recv');

            // If we have crypto, try to decrypt
            if (tuyaCrypto && data.length > 17) {
                try {
                    // Decode BLE framing first
                    const deframedData = deframeBLEPacket(data);
                    if (deframedData) {
                        const decrypted = await tuyaCrypto.decryptPacket(deframedData);
                        console.log('Decrypted:', Array.from(decrypted).map(b => b.toString(16).padStart(2, '0')).join(' '));

                        const parsed = tuyaCrypto.parsePacket(decrypted);
                        console.log('Parsed packet:', parsed);
                        handleTuyaResponse(parsed);
                    }
                } catch (e) {
                    console.log('Decrypt failed, trying plain text:', e);
                    handlePlainResponse(data);
                }
            } else {
                handlePlainResponse(data);
            }
        }

        // Deframe BLE packet (reverse of encodeForTransmission)
        function deframeBLEPacket(data) {
            if (data.length < 3) return null;

            let offset = 0;

            // Read subpackage number (varint)
            let subpkgNum = 0;
            let multiplier = 1;
            while (offset < 4) {
                const byte = data[offset++];
                subpkgNum += (byte & 0x7F) * multiplier;
                multiplier *= 128;
                if ((byte & 0x80) === 0) break;
            }

            // If first packet, read total length
            if (subpkgNum === 0) {
                let totalLen = 0;
                multiplier = 1;
                while (offset < data.length && offset < 8) {
                    const byte = data[offset++];
                    totalLen += (byte & 0x7F) * multiplier;
                    multiplier *= 128;
                    if ((byte & 0x80) === 0) break;
                }

                // Version and sequence byte
                offset++;
            }

            // Return the payload data
            return data.slice(offset);
        }

        function handlePlainResponse(data) {
            const text = new TextDecoder().decode(data);
            console.log('Received text:', text);

            try {
                const response = JSON.parse(text);
                handleResponse(response);
            } catch (e) {
                handleTextResponse(text);
            }
        }

        function handleTuyaResponse(parsed) {
            const { cmdType, payload } = parsed;

            console.log('Tuya CMD:', '0x' + cmdType.toString(16).padStart(4, '0'));

            // FRM_QRY_DEV_INFO_REQ response
            if (cmdType === 0x0000) {
                console.log('Device info response received');
                showToast('‚úÖ', 'Device info received', 'success');
            }
            // FRM_PAIR_REQ response
            else if (cmdType === 0x0001) {
                console.log('Pairing response');
                // Extract pair random if present
                if (payload.length >= 6) {
                    tuyaCrypto.setPairRandom(payload.slice(0, 6));
                    console.log('Pair random set');
                }
            }
            // FRM_STAT_REPORT (DP status)
            else if (cmdType === 0x8001 || cmdType === 0x8006) {
                console.log('DP Status report');
                parseDPData(payload);
            }
            // FRM_DOWNLINK_TRANSPARENT response
            else if (cmdType === 0x801B || cmdType === 0x801C) {
                console.log('Transparent data response, payload length:', payload.length);
                try {
                    // Format: flags(2) + channel(2) + json_data
                    // Skip 4 bytes header
                    const jsonStr = new TextDecoder().decode(payload.slice(4));
                    console.log('JSON string:', jsonStr);
                    const response = JSON.parse(jsonStr);
                    handleResponse(response);
                } catch (e) {
                    console.log('Failed to parse transparent data:', e);
                    // Try without header skip (legacy format)
                    try {
                        const jsonStr = new TextDecoder().decode(payload);
                        const response = JSON.parse(jsonStr);
                        handleResponse(response);
                    } catch (e2) {
                        console.log('Also failed legacy parse:', e2);
                    }
                }
            }
            else {
                console.log('Unknown command type:', cmdType);
            }
        }

        function parseDPData(payload) {
            // DP format varies, just log for now
            console.log('DP Data:', payload);
        }

        function handleResponse(response) {
            console.log('Parsed response:', response);

            if (response.type === 'status') {
                updateStatusDisplay(response);
            } else if (response.type === 'wifi_list') {
                displayWifiList(response.networks || []);
            } else if (response.type === 'ack') {
                showToast('‚úÖ', response.message || 'Command successful', 'success');
            } else if (response.type === 'error') {
                showToast('‚ùå', response.message || 'Command failed', 'error');
            }
        }

        function handleTextResponse(text) {
            if (text.startsWith('ok:')) {
                showToast('‚úÖ', text.substring(3), 'success');
            } else if (text.startsWith('error:')) {
                showToast('‚ùå', text.substring(6), 'error');
            }
        }

        // Send device info query (initiates handshake)
        async function sendDeviceInfoQuery() {
            if (!writeCharacteristic || !tuyaCrypto) {
                console.log('Not ready to send device query');
                return;
            }

            try {
                // Build device info query command (CMD 0x0000)
                const packet = tuyaCrypto.createDeviceInfoQuery();

                // For unencrypted mode 0: prepend mode byte to packet data
                // Format: mode(1) + packet_data(N)
                const withMode = new Uint8Array(1 + packet.length);
                withMode[0] = 0;  // Mode 0 = no encryption
                withMode.set(packet, 1);

                // Now frame the whole thing (mode + packet)
                const framedPacket = tuyaCrypto.encodeForTransmission(withMode);

                console.log('Sending device query:', Array.from(framedPacket).map(b => b.toString(16).padStart(2, '0')).join(' '));
                await writeCharacteristic.writeValue(framedPacket);

                console.log('Device info query sent');
            } catch (error) {
                console.error('Failed to send device query:', error);
            }
        }

        // Send encrypted command
        async function sendTuyaCommand(cmdType, data) {
            if (!writeCharacteristic || !tuyaCrypto) {
                showToast('‚ùå', 'Not connected to device', 'error');
                return false;
            }

            try {
                // Build packet
                const packet = tuyaCrypto.buildPacket(cmdType, data);

                // Encrypt with mode 11 (initial auth)
                const encrypted = await tuyaCrypto.encryptPacket(packet, 11);

                // Frame for transmission
                const framed = tuyaCrypto.encodeForTransmission(encrypted);

                console.log('Sending encrypted:', Array.from(framed).map(b => b.toString(16).padStart(2, '0')).join(' '));
                await writeCharacteristic.writeValue(framed);

                return true;
            } catch (error) {
                console.error('Send error:', error);
                showToast('‚ùå', 'Failed to send command', 'error');
                return false;
            }
        }

        // Send plain JSON command (fallback for simple config service)
        async function sendCommand(cmd) {
            if (!writeCharacteristic) {
                showToast('‚ùå', 'Not connected to device', 'error');
                return false;
            }

            // If we have Tuya crypto, use transparent data channel
            if (tuyaCrypto) {
                try {
                    // Determine channel type based on command
                    // Channel 1 = BLE_CHANNLE_NETCFG (for WiFi config)
                    // Channel 0 = Custom config channel (for TCP settings, status, etc.)
                    let channelType = 0;  // Default to custom channel
                    
                    if (cmd.cmd === 'set_wifi' && cmd.ssid) {
                        // Use NETCFG channel for WiFi - format: {ssid, pwd, token}
                        channelType = 1;  // BLE_CHANNLE_NETCFG
                        cmd = {
                            ssid: cmd.ssid,
                            pwd: cmd.password || '',
                            token: 'webble'  // Required by netcfg handler
                        };
                    }
                    
                    const packet = tuyaCrypto.createTransparentDataCmd(channelType, cmd);
                    // Use mode 0 (unencrypted) since we haven't completed handshake yet
                    const withMode = await tuyaCrypto.encryptPacket(packet, 0);
                    const framed = tuyaCrypto.encodeForTransmission(withMode);

                    console.log(`Sending via Tuya protocol (channel ${channelType}, mode 0):`, 
                        Array.from(framed).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    await writeCharacteristic.writeValue(framed);
                    return true;
                } catch (error) {
                    console.error('Tuya send failed:', error);
                }
            }

            // Fallback to plain JSON
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(JSON.stringify(cmd));
                await writeCharacteristic.writeValue(data);
                console.log('Sent:', cmd);
                return true;
            } catch (error) {
                console.error('Send error:', error);
                showToast('‚ùå', 'Failed to send command', 'error');
                return false;
            }
        }

        // ===== TCP Settings =====
        async function saveTcpSettings() {
            const host = document.getElementById('tcpHost').value.trim();
            const port = parseInt(document.getElementById('tcpPort').value) || 5000;
            const token = document.getElementById('tcpToken').value.trim();

            if (!host) {
                showToast('‚ö†Ô∏è', 'Please enter server host', 'error');
                return;
            }

            const cmd = {
                cmd: 'set_tcp',
                host: host,
                port: port,
                token: token
            };

            if (await sendCommand(cmd)) {
                showToast('‚úÖ', 'TCP settings saved! Reboot to apply.', 'success');
            }
        }

        // ===== WiFi Settings =====
        async function scanWifi() {
            const btn = document.getElementById('scanWifiBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Scanning...';

            await sendCommand({ cmd: 'wifi_scan' });

            setTimeout(() => {
                btn.disabled = false;
                btn.innerHTML = '<span>üîç</span> Scan WiFi';
            }, 3000);
        }

        async function disconnectWifi() {
            const btn = document.getElementById('disconnectWifiBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Disconnecting...';

            await sendCommand({ cmd: 'wifi_disconnect' });

            setTimeout(() => {
                btn.disabled = false;
                btn.innerHTML = '<span>üì¥</span> Disconnect WiFi';
            }, 2000);
        }

        function displayWifiList(networks) {
            const container = document.getElementById('wifiList');

            if (networks.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No networks found</div>';
                return;
            }

            container.innerHTML = networks.map(net => `
                <div class="wifi-item" onclick="selectWifi('${net.ssid}')">
                    <span class="ssid">${net.ssid}</span>
                    <span class="signal">${getSignalIcon(net.rssi)} ${net.rssi} dBm</span>
                </div>
            `).join('');
        }

        function getSignalIcon(rssi) {
            if (rssi > -50) return 'üì∂';
            if (rssi > -70) return 'üì∂';
            return 'üì∂';
        }

        function selectWifi(ssid) {
            // Update selection UI
            document.querySelectorAll('.wifi-item').forEach(el => el.classList.remove('selected'));
            event.target.closest('.wifi-item').classList.add('selected');

            // Fill in SSID
            document.getElementById('wifiSsid').value = ssid;
            document.getElementById('wifiPassword').focus();
        }

        async function saveWifiSettings() {
            const ssid = document.getElementById('wifiSsid').value.trim();
            const password = document.getElementById('wifiPassword').value;

            if (!ssid) {
                showToast('‚ö†Ô∏è', 'Please enter WiFi SSID', 'error');
                return;
            }

            const cmd = {
                cmd: 'set_wifi',
                ssid: ssid,
                password: password
            };

            if (await sendCommand(cmd)) {
                showToast('‚úÖ', 'WiFi settings saved! Connecting...', 'success');
            }
        }

        // ===== Status =====
        async function refreshStatus() {
            await sendCommand({ cmd: 'get_status' });
        }

        function updateStatusDisplay(data) {
            document.getElementById('wifiStatus').textContent = data.wifi_connected ? '‚úÖ Connected' : '‚ùå Disconnected';
            document.getElementById('currentSsid').textContent = data.ssid || '--';
            document.getElementById('ipAddress').textContent = data.ip || '--';
            document.getElementById('tcpServerStatus').textContent = data.tcp_connected ? '‚úÖ Connected' : '‚ùå Disconnected';
            document.getElementById('freeHeap').textContent = data.heap ? `${data.heap} bytes` : '--';

            // Update TCP settings if available
            if (data.tcp_host) {
                document.getElementById('tcpHost').value = data.tcp_host;
            }
            if (data.tcp_port) {
                document.getElementById('tcpPort').value = data.tcp_port;
            }
        }

        async function rebootDevice() {
            if (confirm('Are you sure you want to reboot the device?')) {
                await sendCommand({ cmd: 'reboot' });
                showToast('üîÑ', 'Device is rebooting...', 'success');
            }
        }

        // ===== Toast =====
        function showToast(icon, message, type = '') {
            const toast = document.getElementById('toast');
            const toastIcon = document.getElementById('toastIcon');
            const toastMessage = document.getElementById('toastMessage');

            toast.className = 'toast ' + type;
            toastIcon.textContent = icon;
            toastMessage.textContent = message;

            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
    </script>
</body>

</html>