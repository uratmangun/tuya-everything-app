<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T5AI DevKit Controller</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono&display=swap"
        rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-primary: #0a0f1a;
            --bg-secondary: #111827;
            --bg-card: rgba(17, 24, 39, 0.8);
            --border-color: rgba(55, 65, 81, 0.5);
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --accent-cyan: #06b6d4;
            --accent-cyan-glow: rgba(6, 182, 212, 0.3);
            --accent-green: #10b981;
            --accent-green-glow: rgba(16, 185, 129, 0.3);
            --accent-red: #ef4444;
            --accent-red-glow: rgba(239, 68, 68, 0.3);
            --accent-orange: #f59e0b;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            background-image:
                radial-gradient(ellipse at top, rgba(6, 182, 212, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(16, 185, 129, 0.08) 0%, transparent 50%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-green) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        header p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .nav-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding: 8px 16px;
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 8px;
            color: var(--accent-cyan);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .nav-link:hover {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.5);
            transform: translateY(-1px);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 40px -20px rgba(0, 0, 0, 0.5);
        }

        .card h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card h2 span {
            font-size: 1.2rem;
        }

        /* Status Card */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .status-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
        }

        .status-item label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .status-value {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green-glow);
        }

        .status-dot.disconnected {
            background: var(--accent-red);
            box-shadow: 0 0 10px var(--accent-red-glow);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Send Message Card */
        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        textarea,
        input[type="text"] {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.95rem;
            resize: vertical;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        textarea:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px var(--accent-cyan-glow);
        }

        textarea {
            min-height: 100px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan) 0%, #0891b2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px -10px var(--accent-cyan-glow);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .btn-group .btn {
            padding: 0.75rem;
            font-size: 0.85rem;
        }

        /* Console/Log Card */
        .console {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            height: 300px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.8;
        }

        .console::-webkit-scrollbar {
            width: 6px;
        }

        .console::-webkit-scrollbar-track {
            background: transparent;
        }

        .console::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .log-time {
            color: var(--text-secondary);
        }

        .log-type {
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin: 0 0.5rem;
        }

        .log-type.info {
            background: rgba(6, 182, 212, 0.2);
            color: var(--accent-cyan);
        }

        .log-type.sent {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .log-type.received {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-orange);
        }

        .log-type.error {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .log-type.status {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
        }

        .log-message {
            color: var(--text-primary);
        }

        /* Quick Commands */
        .quick-commands {
            grid-column: span 2;
        }

        @media (max-width: 768px) {
            .quick-commands {
                grid-column: span 1;
            }
        }

        .command-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
        }

        .command-btn {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .command-btn:hover {
            background: rgba(6, 182, 212, 0.1);
            border-color: var(--accent-cyan);
            transform: translateY(-2px);
        }

        .command-btn .icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        /* Connection Info */
        .connection-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .connection-info code {
            color: var(--accent-cyan);
            background: rgba(6, 182, 212, 0.1);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
        }

        .full-width {
            grid-column: span 2;
        }

        @media (max-width: 768px) {
            .full-width {
                grid-column: span 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üéõÔ∏è T5AI DevKit Controller</h1>
            <p>Real-time communication between Web UI and DevKit</p>
            <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <a href="/ble" class="nav-link">üì∂ BLE Configuration</a>
                <a href="#" class="nav-link" onclick="logout(); return false;"
                    style="background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3); color: #ef4444;">üö™
                    Logout</a>
            </div>
        </header>

        <div class="grid">
            <!-- Status Card -->
            <div class="card">
                <h2><span>üìä</span> Connection Status</h2>
                <div class="status-grid">
                    <div class="status-item">
                        <label>DevKit</label>
                        <div class="status-value">
                            <span id="devkit-dot" class="status-dot disconnected"></span>
                            <span id="devkit-status">Disconnected</span>
                        </div>
                    </div>
                    <div class="status-item">
                        <label>WebSocket</label>
                        <div class="status-value">
                            <span id="ws-dot" class="status-dot disconnected"></span>
                            <span id="ws-status">Connecting...</span>
                        </div>
                    </div>
                    <div class="status-item">
                        <label>DevKit IP</label>
                        <div class="status-value">
                            <span id="devkit-ip">--</span>
                        </div>
                    </div>
                    <div class="status-item">
                        <label>Messages</label>
                        <div class="status-value">
                            <span id="msg-count">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quick Commands -->
            <div class="card quick-commands">
                <h2><span>‚ö°</span> Quick Commands</h2>
                <div class="command-grid">
                    <button class="command-btn" onclick="sendQuickCommand('ping')">
                        <div class="icon">üèì</div>
                        <div>PING</div>
                    </button>
                    <button class="command-btn" onclick="sendQuickCommand('status')">
                        <div class="icon">üìä</div>
                        <div>STATUS</div>
                    </button>
                    <button class="command-btn" onclick="sendQuickCommand('audio play')">
                        <div class="icon">üîä</div>
                        <div>PLAY AUDIO</div>
                    </button>
                    <button class="command-btn" onclick="sendQuickCommand('audio stop')">
                        <div class="icon">üîá</div>
                        <div>STOP AUDIO</div>
                    </button>
                    <button class="command-btn" onclick="sendQuickCommand('mem')">
                        <div class="icon">üíæ</div>
                        <div>MEMORY</div>
                    </button>
                </div>
                <!-- Live mic audio player (always available when DevKit connected) -->
                <div id="mic-status"
                    style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.3); border-radius: 8px; display: none;">
                    <div style="margin-bottom: 0.5rem; font-size: 0.85rem;">
                        <span style="color: var(--accent-green);">üé§ Live Microphone Stream</span>
                        <span id="mic-stream-status" style="color: var(--text-secondary); margin-left: 0.5rem;">(click
                            Start to listen)</span>
                    </div>
                    <!-- Mic stream waveform canvas -->
                    <canvas id="mic-waveform-canvas" width="280" height="40"
                        style="display: none; background: rgba(0,0,0,0.3); border-radius: 4px; margin-bottom: 0.5rem; width: 100%;"></canvas>
                    <div class="btn-group">
                        <button id="btn-mic-start" class="btn btn-primary" onclick="startMicStream()">‚ñ∂ Start</button>
                        <button id="btn-mic-stop" class="btn btn-secondary" onclick="stopMicStream()" disabled>‚èπ
                            Stop</button>
                    </div>

                    <!-- Volume Controls -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                        <div style="margin-bottom: 0.75rem; font-size: 0.85rem;">
                            <span style="color: var(--accent-orange);">üéöÔ∏è Volume Controls</span>
                        </div>
                        <!-- Speaker Volume -->
                        <div style="margin-bottom: 0.75rem;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <label style="font-size: 0.8rem; color: var(--text-secondary);">üîä Speaker</label>
                                <span id="speaker-vol-value"
                                    style="font-size: 0.8rem; color: var(--accent-cyan); font-family: 'JetBrains Mono', monospace;">70</span>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="range" id="speaker-volume" min="0" max="100" value="70"
                                    style="flex: 1; height: 6px; -webkit-appearance: none; background: rgba(0,0,0,0.4); border-radius: 3px; cursor: pointer;"
                                    oninput="document.getElementById('speaker-vol-value').textContent = this.value">
                                <button class="btn btn-secondary"
                                    onclick="setVolume('speaker', document.getElementById('speaker-volume').value)"
                                    style="padding: 0.4rem 0.75rem; font-size: 0.75rem; min-width: auto;">Set</button>
                            </div>
                        </div>
                        <!-- Mic Volume -->
                        <div style="margin-bottom: 0.5rem;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <label style="font-size: 0.8rem; color: var(--text-secondary);">üé§ Mic Gain</label>
                                <span id="mic-vol-value"
                                    style="font-size: 0.8rem; color: var(--accent-green); font-family: 'JetBrains Mono', monospace;">50</span>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="range" id="mic-volume" min="0" max="100" value="50"
                                    style="flex: 1; height: 6px; -webkit-appearance: none; background: rgba(0,0,0,0.4); border-radius: 3px; cursor: pointer;"
                                    oninput="document.getElementById('mic-vol-value').textContent = this.value">
                                <button class="btn btn-secondary"
                                    onclick="setVolume('mic', document.getElementById('mic-volume').value)"
                                    style="padding: 0.4rem 0.75rem; font-size: 0.75rem; min-width: auto;">Set</button>
                            </div>
                        </div>
                        <div id="volume-status"
                            style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem; display: none;">
                        </div>
                    </div>

                    <!-- Two-way audio: Talk to DevKit (Record & Send) -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                        <div style="margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--accent-cyan);">üîä Voice Message to DevKit</span>
                            <span id="talk-status" style="color: var(--text-secondary); margin-left: 0.5rem;">(click to
                                record)</span>
                        </div>
                        <!-- Timer display -->
                        <div id="record-timer"
                            style="font-size: 1.5rem; font-weight: bold; font-family: monospace; margin: 0.5rem 0; display: none;">
                            00:00
                        </div>
                        <!-- Waveform canvas -->
                        <canvas id="waveform-canvas" width="280" height="40"
                            style="display: none; background: rgba(0,0,0,0.3); border-radius: 4px; margin-bottom: 0.5rem;"></canvas>
                        <!-- Single toggle button -->
                        <button id="btn-voice-toggle" class="btn btn-primary" onclick="toggleVoiceRecord()"
                            style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); width: 100%;">
                            üéôÔ∏è Start Recording
                        </button>
                        <div id="voice-sending" style="display: none; color: var(--accent-cyan); margin-top: 0.5rem;">
                            ‚è≥ Sending to DevKit...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Console Log -->
            <div class="card full-width">
                <h2><span>üìú</span> Communication Log</h2>
                <div class="console" id="console">
                    <div class="log-entry">
                        <span class="log-time">[--:--:--]</span>
                        <span class="log-type info">INFO</span>
                        <span class="log-message">Waiting for WebSocket connection...</span>
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="clearLog()">
                        <span>üóëÔ∏è</span> Clear Log
                    </button>
                    <button class="btn btn-secondary" onclick="reconnect()">
                        <span>üîÑ</span> Reconnect
                    </button>
                </div>
            </div>

            <!-- Connection Info -->
            <div class="card full-width">
                <h2><span>‚ÑπÔ∏è</span> Connection Info</h2>
                <div class="connection-info">
                    <p><strong>For DevKit firmware:</strong></p>
                    <p style="margin-top: 0.5rem;">
                        Connect to: <code id="server-info">ws://localhost:5000</code>
                    </p>
                    <p style="margin-top: 0.5rem; color: var(--text-secondary);">
                        The DevKit should open a TCP connection to the server on port 5000.
                        Messages are exchanged using a simple length-prefixed protocol: [LEN:4bytes][DATA:Nbytes]
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let msgCount = 0;
        let authToken = null;

        // WebSocket URL - use same origin, same port (WebSocket is on same port as HTTP)
        // Automatically use wss:// for HTTPS, ws:// for HTTP
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}`;

        // Fetch auth token from server (since we're already HTTP authenticated)
        async function getAuthToken() {
            try {
                const res = await fetch('/api/token');
                const data = await res.json();
                return data.token;
            } catch (err) {
                log('error', 'Failed to get auth token');
                return null;
            }
        }

        async function connect() {
            // Get token first
            if (!authToken) {
                log('info', 'Fetching auth token...');
                authToken = await getAuthToken();
                if (!authToken) {
                    log('error', 'Could not get auth token. Please refresh and login.');
                    return;
                }
            }

            log('info', `Connecting to WebSocket: ${wsUrl}`);

            ws = new WebSocket(wsUrl);
            let wsPingInterval = null;

            ws.onopen = () => {
                log('info', 'WebSocket connected, authenticating...');
                // Send keepalive ping every 30 seconds to prevent Cloudflare timeout
                wsPingInterval = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 30000);
            };

            ws.onmessage = (event) => {
                // Handle text/JSON data only (audio now via HTTP stream)
                if (event.data instanceof Blob) return;

                try {
                    const data = JSON.parse(event.data);
                    handleMessage(data);
                } catch (err) {
                    // Ignore non-JSON
                }
            };

            ws.onclose = () => {
                log('info', 'WebSocket disconnected');
                updateWsStatus(false);
                if (wsPingInterval) {
                    clearInterval(wsPingInterval);
                    wsPingInterval = null;
                }

                // Auto-reconnect after 2 seconds
                setTimeout(() => {
                    if (!ws || ws.readyState === WebSocket.CLOSED) {
                        connect();
                    }
                }, 2000);
            };

            ws.onerror = (err) => {
                log('error', 'WebSocket error');
            };
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'auth_required':
                    // Send authentication token
                    log('info', 'Sending authentication...');
                    ws.send(JSON.stringify({
                        type: 'auth',
                        token: authToken
                    }));
                    break;

                case 'auth_success':
                    log('info', '‚úì Authenticated successfully');
                    updateWsStatus(true);
                    if (data.devkit) {
                        updateDevKitStatus(data.devkit.connected);
                    }
                    if (data.serverIP) {
                        document.getElementById('server-info').textContent =
                            `${data.serverIP}:${data.tcpPort}`;
                    }
                    break;

                case 'auth_failed':
                    log('error', 'Authentication failed - invalid token');
                    updateWsStatus(false);
                    break;

                case 'devkit_status':
                    updateDevKitStatus(data.connected, data.address);
                    if (data.serverIP) {
                        document.getElementById('server-info').textContent =
                            `${data.serverIP}:${data.tcpPort}`;
                    }
                    log('status', data.connected ?
                        `DevKit connected from ${data.address}` :
                        'DevKit disconnected');
                    break;

                case 'devkit_message':
                    log('received', data.data);
                    msgCount++;
                    document.getElementById('msg-count').textContent = msgCount;

                    // Handle volume status responses
                    if (data.data && data.data.startsWith('ok:vol:')) {
                        const parts = data.data.split(':');
                        if (parts.length >= 4) {
                            const type = parts[2];
                            const vol = parseInt(parts[3]);
                            if (type === 'speaker') {
                                document.getElementById('speaker-volume').value = vol;
                                document.getElementById('speaker-vol-value').textContent = vol;
                            } else if (type === 'mic') {
                                document.getElementById('mic-volume').value = vol;
                                document.getElementById('mic-vol-value').textContent = vol;
                            }
                            const statusEl = document.getElementById('volume-status');
                            statusEl.textContent = `‚úì ${type} volume set to ${vol}`;
                            statusEl.style.color = 'var(--accent-green)';
                            statusEl.style.display = 'block';
                        }
                    }
                    break;

                case 'sent_to_devkit':
                    log('sent', data.data);
                    break;

                case 'error':
                    log('error', data.message);
                    break;
            }
        }

        function sendMessage() {
            const input = document.getElementById('message');
            const message = input.value.trim();

            if (!message) return;

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('error', 'WebSocket not connected');
                return;
            }

            ws.send(JSON.stringify({
                type: 'send_to_devkit',
                data: message
            }));

            input.value = '';
        }

        function sendQuickCommand(cmd) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('error', 'WebSocket not connected');
                return;
            }

            ws.send(JSON.stringify({
                type: 'send_to_devkit',
                data: cmd
            }));
        }

        function updateWsStatus(connected) {
            const dot = document.getElementById('ws-dot');
            const status = document.getElementById('ws-status');

            dot.className = 'status-dot ' + (connected ? 'connected' : 'disconnected');
            status.textContent = connected ? 'Authenticated' : 'Disconnected';
        }

        function updateDevKitStatus(connected, address) {
            const dot = document.getElementById('devkit-dot');
            const status = document.getElementById('devkit-status');
            const ipEl = document.getElementById('devkit-ip');
            const micStatus = document.getElementById('mic-status');

            dot.className = 'status-dot ' + (connected ? 'connected' : 'disconnected');
            status.textContent = connected ? 'Connected' : 'Disconnected';
            ipEl.textContent = address || '--';

            // Show/hide mic controls based on connection
            if (connected) {
                micStatus.style.display = 'block';
            } else {
                micStatus.style.display = 'none';
                // Use local-only stop to avoid sending "mic off" during brief disconnects
                // The DevKit may reconnect quickly, and we don't want to interrupt its state
                if (typeof stopMicStreamLocal === 'function') {
                    stopMicStreamLocal();
                }
            }
        }


        // ==================== WebRTC Audio Streaming (Opus) ====================
        let peerConnection = null;
        let micStreamActive = false;
        let remoteAudioElement = null;

        // Create audio element for WebRTC playback
        function createAudioElement() {
            if (remoteAudioElement) return remoteAudioElement;

            remoteAudioElement = document.createElement('audio');
            remoteAudioElement.id = 'webrtc-audio';
            remoteAudioElement.autoplay = true;
            remoteAudioElement.controls = false;
            document.body.appendChild(remoteAudioElement);
            return remoteAudioElement;
        }

        // G.711 lookup table - kept for legacy fallback but not used in WebRTC mode
        const AUDIO_SAMPLE_RATE = 16000;
        const ULAW_LOOKUP = new Float32Array(256);
        (function initUlawTable() {
            for (let i = 0; i < 256; i++) {
                let uval = ~i & 0xFF; // Invert bits as per u-law standard
                let t = ((uval & 0x0F) << 3) + 0x84;
                t <<= ((uval & 0x70) >> 4);
                let sign = (uval & 0x80) ? -1 : 1;
                // Normalize 16-bit range to Float32 (-1.0 to 1.0)
                ULAW_LOOKUP[i] = (sign * (t - 0x84)) / 32768.0;
            }
        })();

        // Decode G.711 u-law to Float32 samples
        function decodeG711(g711Data) {
            const floatBuffer = new Float32Array(g711Data.length);
            for (let i = 0; i < g711Data.length; i++) {
                floatBuffer[i] = ULAW_LOOKUP[g711Data[i]];
            }
            return floatBuffer;
        }

        // Play a single G.711 packet immediately
        function playG711Packet(dataBuffer) {
            if (!audioContext || audioContext.state !== 'running') return;

            // Parse packet: [SEQ:1 byte][G711_DATA:N bytes]
            const rawBytes = new Uint8Array(dataBuffer);
            if (rawBytes.length < 2) return;

            // Skip sequence number (byte 0), decode G.711 data (bytes 1+)
            const g711Data = rawBytes.subarray(1);
            const floatSamples = decodeG711(g711Data);

            // Create audio buffer at 16kHz
            const buffer = audioContext.createBuffer(1, floatSamples.length, AUDIO_SAMPLE_RATE);
            buffer.getChannelData(0).set(floatSamples);

            // Create and schedule playback
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);

            // Track for cleanup
            activeSources.push(source);
            source.onended = () => {
                const idx = activeSources.indexOf(source);
                if (idx > -1) activeSources.splice(idx, 1);
            };

            // Simple jitter handling: if we're behind, catch up
            const now = audioContext.currentTime;
            if (nextPlayTime < now) {
                nextPlayTime = now + 0.02; // 20ms buffer
            }

            source.start(nextPlayTime);
            nextPlayTime += buffer.duration;
        }

        // Connect to WebRTC audio stream
        async function connectWebRTC() {
            try {
                // Create peer connection with STUN + self-hosted TURN
                const config = {
                    iceServers: [
                        // Google's free STUN (works for ~80% of connections)
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        // Self-hosted TURN server (relay for remaining ~20%)
                        {
                            urls: 'turn:YOUR_VPS_IP:3478',
                            username: 'turnuser',
                            credential: 'TuyaT5DevKit2024'
                        },
                        {
                            urls: 'turn:YOUR_VPS_IP:3478?transport=tcp',
                            username: 'turnuser',
                            credential: 'TuyaT5DevKit2024'
                        }
                    ]
                };

                peerConnection = new RTCPeerConnection(config);

                // Handle incoming audio track
                peerConnection.ontrack = function (event) {
                    log('info', 'üéµ WebRTC audio track received');
                    const audioEl = createAudioElement();
                    audioEl.srcObject = event.streams[0];
                    audioEl.play().catch(e => {
                        log('warn', 'Audio autoplay blocked');
                    });
                    // Start waveform visualization for received mic audio
                    startMicStreamWaveform(event.streams[0]);
                };

                // Log connection state changes
                peerConnection.onconnectionstatechange = function () {
                    log('info', `WebRTC: ${peerConnection.connectionState}`);
                    if (peerConnection.connectionState === 'connected') {
                        document.getElementById('mic-stream-status').textContent = 'üéµ WebRTC (Opus)';
                        document.getElementById('mic-stream-status').style.color = 'var(--accent-green)';
                        document.getElementById('mic-waveform-canvas').style.display = 'block';
                    } else if (peerConnection.connectionState === 'failed') {
                        if (micStreamActive) {
                            setTimeout(() => { if (micStreamActive) connectWebRTC(); }, 2000);
                        }
                    } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'closed') {
                        stopMicStreamWaveform();
                        document.getElementById('mic-waveform-canvas').style.display = 'none';
                    }
                };

                // Log ICE connection state
                peerConnection.oniceconnectionstatechange = function () {
                    log('info', `ICE: ${peerConnection.iceConnectionState}`);
                };

                // Log ICE candidates
                peerConnection.onicecandidate = function (event) {
                    if (event.candidate) {
                        log('info', `ICE candidate: ${event.candidate.type || 'unknown'} ${event.candidate.protocol || ''}`);
                    }
                };

                // Add receive-only audio transceiver
                peerConnection.addTransceiver('audio', { direction: 'recvonly' });

                // Create and send offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                log('info', 'Sending WebRTC offer...');
                const response = await fetch('/webrtc-offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(offer)
                });

                if (!response.ok) throw new Error(`Server: ${response.status}`);

                const answer = await response.json();
                await peerConnection.setRemoteDescription(answer);
                log('info', '‚úÖ WebRTC connected');

            } catch (error) {
                log('error', 'WebRTC error: ' + error.message);
                throw error;
            }
        }

        async function startMicStream() {
            // Prevent multiple starts
            if (micStreamActive) {
                log('warn', 'Mic stream already active');
                return;
            }

            try {
                log('info', 'Starting WebRTC audio stream...');

                // Send "mic on" command to DevKit to start UDP streaming
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'send_to_devkit',
                        data: 'mic on'
                    }));
                    await new Promise(r => setTimeout(r, 200));
                } else {
                    log('warn', 'WebSocket not connected');
                }

                micStreamActive = true;
                document.getElementById('btn-mic-start').disabled = true;
                document.getElementById('btn-mic-stop').disabled = false;
                document.getElementById('mic-stream-status').textContent = 'üîÑ Connecting WebRTC...';
                document.getElementById('mic-stream-status').style.color = 'var(--accent-orange)';

                // Connect to WebRTC
                await connectWebRTC();

            } catch (err) {
                log('error', 'Mic stream error: ' + err.message);
                micStreamActive = false;
                document.getElementById('btn-mic-start').disabled = false;
                document.getElementById('btn-mic-stop').disabled = true;
                document.getElementById('mic-stream-status').textContent = '(click Start to listen)';
                document.getElementById('mic-stream-status').style.color = 'var(--text-secondary)';
            }
        }



        // Stop mic stream locally (audio playback only, no command to DevKit)
        function stopMicStreamLocal() {
            micStreamActive = false;

            // Stop mic stream waveform
            stopMicStreamWaveform();

            // Close WebRTC peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Stop audio element
            if (remoteAudioElement) {
                remoteAudioElement.srcObject = null;
            }

            // Update UI
            document.getElementById('btn-mic-start').disabled = false;
            document.getElementById('btn-mic-stop').disabled = true;
            document.getElementById('mic-stream-status').textContent = '(click Start to listen)';
            document.getElementById('mic-stream-status').style.color = 'var(--text-secondary)';
            document.getElementById('mic-waveform-canvas').style.display = 'none';
        }



        // Stop mic stream and send command to DevKit (user-initiated stop)
        function stopMicStream() {
            log('info', 'Stopping mic stream...');

            // Send "mic off" command to DevKit to stop UDP streaming
            if (ws && ws.readyState === WebSocket.OPEN) {
                log('info', 'Sending "mic off" command to DevKit...');
                ws.send(JSON.stringify({
                    type: 'send_to_devkit',
                    data: 'mic off'
                }));
            }

            // Stop local playback
            stopMicStreamLocal();
        }

        // ==================== Two-Way Audio (Talk Back) ====================
        let localMicStream = null;
        // ==================== Voice Recording (Record & Send) ====================
        let voiceRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordStartTime = 0;
        let recordTimerInterval = null;
        let audioContext = null;
        let analyser = null;
        let waveformInterval = null;
        let micStreamAudioContext = null;
        let micStreamAnalyser = null;
        let micStreamWaveformInterval = null;
        const MAX_RECORD_SECONDS = 30; // 30 second limit

        // ==================== Mic Stream Waveform ====================
        // Start waveform visualization for mic stream (WebRTC received audio)
        function startMicStreamWaveform(stream) {
            if (!stream) return;

            // Stop any existing waveform first
            stopMicStreamWaveform();

            try {
                micStreamAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                micStreamAnalyser = micStreamAudioContext.createAnalyser();
                micStreamAnalyser.fftSize = 256;

                const source = micStreamAudioContext.createMediaStreamSource(stream);
                source.connect(micStreamAnalyser);

                const canvas = document.getElementById('mic-waveform-canvas');
                const ctx = canvas.getContext('2d');
                const bufferLength = micStreamAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                function draw() {
                    if (!micStreamActive || !micStreamAudioContext) return;

                    micStreamAnalyser.getByteFrequencyData(dataArray);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = (dataArray[i] / 255) * canvas.height;
                        // Use green hue for receiving audio (to differentiate from sending)
                        ctx.fillStyle = `hsl(${120 + dataArray[i] / 4}, 100%, 50%)`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }

                    micStreamWaveformInterval = requestAnimationFrame(draw);
                }

                draw();
                log('info', 'üé® Mic stream waveform started');
            } catch (err) {
                log('warn', 'Could not start mic stream waveform: ' + err.message);
            }
        }

        // Stop mic stream waveform visualization
        function stopMicStreamWaveform() {
            if (micStreamWaveformInterval) {
                cancelAnimationFrame(micStreamWaveformInterval);
                micStreamWaveformInterval = null;
            }
            if (micStreamAudioContext) {
                micStreamAudioContext.close().catch(() => { });
                micStreamAudioContext = null;
                micStreamAnalyser = null;
            }
            // Clear the canvas
            const canvas = document.getElementById('mic-waveform-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Toggle voice recording (single button)
        async function toggleVoiceRecord() {
            if (voiceRecording) {
                stopVoiceRecord();
            } else {
                await startVoiceRecord();
            }
        }

        // Start voice recording
        async function startVoiceRecord() {
            if (voiceRecording) return;

            try {
                log('info', 'üéôÔ∏è Starting voice recording...');

                // Request microphone
                localMicStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Use audio/webm with Opus codec (fast, small)
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus'
                    : 'audio/webm';

                mediaRecorder = new MediaRecorder(localMicStream, { mimeType });
                recordedChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    await sendVoiceMessage();
                };

                // Start recording
                mediaRecorder.start(100); // collect data every 100ms
                voiceRecording = true;
                recordStartTime = Date.now();

                // Update UI
                document.getElementById('btn-voice-toggle').textContent = 'üî¥ Stop Recording';
                document.getElementById('btn-voice-toggle').style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                document.getElementById('talk-status').textContent = 'Recording...';
                document.getElementById('talk-status').style.color = 'var(--accent-red)';
                document.getElementById('record-timer').style.display = 'block';
                document.getElementById('waveform-canvas').style.display = 'block';

                // Start timer
                updateRecordTimer();
                recordTimerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
                    if (elapsed >= MAX_RECORD_SECONDS) {
                        log('warn', '‚è±Ô∏è Max recording time reached (30s)');
                        stopVoiceRecord();
                    } else {
                        updateRecordTimer();
                    }
                }, 100);

                // Start waveform visualization
                startWaveform();

                log('info', `Recording started (max ${MAX_RECORD_SECONDS}s, format: ${mimeType})`);

            } catch (err) {
                log('error', 'Mic access error: ' + err.message);
                resetVoiceUI();
            }
        }

        // Stop voice recording
        function stopVoiceRecord() {
            if (!voiceRecording || !mediaRecorder) return;

            log('info', '‚èπÔ∏è Stopping recording...');
            voiceRecording = false;

            // Stop timer and waveform
            if (recordTimerInterval) {
                clearInterval(recordTimerInterval);
                recordTimerInterval = null;
            }
            stopWaveform();

            // Stop MediaRecorder (will trigger onstop -> sendVoiceMessage)
            if (mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            // Stop mic stream
            if (localMicStream) {
                localMicStream.getTracks().forEach(t => t.stop());
                localMicStream = null;
            }
        }

        // Send recorded voice to server
        async function sendVoiceMessage() {
            if (recordedChunks.length === 0) {
                log('warn', 'No audio recorded');
                resetVoiceUI();
                return;
            }

            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
            const durationMs = Date.now() - recordStartTime;
            log('info', `üì§ Sending voice message (${(blob.size / 1024).toFixed(1)}KB, ${(durationMs / 1000).toFixed(1)}s)`);

            // Show sending state
            document.getElementById('btn-voice-toggle').disabled = true;
            document.getElementById('voice-sending').style.display = 'block';
            document.getElementById('talk-status').textContent = 'Sending...';
            document.getElementById('talk-status').style.color = 'var(--accent-cyan)';

            try {
                const response = await fetch('/api/voice-message', {
                    method: 'POST',
                    headers: { 'Content-Type': blob.type },
                    body: blob
                });

                if (response.ok) {
                    const result = await response.json();
                    log('info', `‚úÖ Voice sent to DevKit (${result.pcmBytes || 0} bytes PCM)`);
                } else {
                    const errorText = await response.text();
                    log('error', `Server error: ${response.status} - ${errorText}`);
                }
            } catch (err) {
                log('error', 'Upload failed: ' + err.message);
            }

            resetVoiceUI();
        }

        // Reset voice UI to idle state
        function resetVoiceUI() {
            voiceRecording = false;
            document.getElementById('btn-voice-toggle').disabled = false;
            document.getElementById('btn-voice-toggle').textContent = 'üéôÔ∏è Start Recording';
            document.getElementById('btn-voice-toggle').style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            document.getElementById('talk-status').textContent = '(click to record)';
            document.getElementById('talk-status').style.color = 'var(--text-secondary)';
            document.getElementById('record-timer').style.display = 'none';
            document.getElementById('waveform-canvas').style.display = 'none';
            document.getElementById('voice-sending').style.display = 'none';
        }

        // Update timer display
        function updateRecordTimer() {
            const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('record-timer').textContent = `${mins}:${secs}`;
        }

        // Start waveform visualization
        function startWaveform() {
            if (!localMicStream) return;

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;

            const source = audioContext.createMediaStreamSource(localMicStream);
            source.connect(analyser);

            const canvas = document.getElementById('waveform-canvas');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                if (!voiceRecording) return;

                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    ctx.fillStyle = `hsl(${200 + dataArray[i] / 2}, 100%, 50%)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }

                waveformInterval = requestAnimationFrame(draw);
            }

            draw();
        }

        // Stop waveform visualization
        function stopWaveform() {
            if (waveformInterval) {
                cancelAnimationFrame(waveformInterval);
                waveformInterval = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        }


        // ==================== Volume Control ====================
        function setVolume(type, value) {
            const vol = parseInt(value);
            if (isNaN(vol) || vol < 0 || vol > 100) {
                log('error', 'Invalid volume value');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('error', 'WebSocket not connected');
                return;
            }

            const cmd = `setvol:${type}:${vol}`;
            log('info', `Setting ${type} volume to ${vol}...`);

            ws.send(JSON.stringify({
                type: 'send_to_devkit',
                data: cmd
            }));

            // Show status
            const statusEl = document.getElementById('volume-status');
            statusEl.textContent = `Setting ${type} volume to ${vol}...`;
            statusEl.style.display = 'block';
            statusEl.style.color = 'var(--accent-orange)';

            // Clear status after 3 seconds
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        // Update volume UI when receiving status from DevKit
        function updateVolumeUI(speakerVol, micVol) {
            if (speakerVol !== undefined) {
                document.getElementById('speaker-volume').value = speakerVol;
                document.getElementById('speaker-vol-value').textContent = speakerVol;
            }
            if (micVol !== undefined) {
                document.getElementById('mic-volume').value = micVol;
                document.getElementById('mic-vol-value').textContent = micVol;
            }
        }

        function log(type, message) {
            const console = document.getElementById('console');
            const time = new Date().toLocaleTimeString();

            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-type ${type}">${type.toUpperCase()}</span>
                <span class="log-message">${escapeHtml(message)}</span>
            `;

            console.appendChild(entry);
            console.scrollTop = console.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function clearLog() {
            document.getElementById('console').innerHTML = '';
            log('info', 'Log cleared');
        }

        function reconnect() {
            if (ws) {
                ws.close();
            }
            setTimeout(connect, 500);
        }

        async function logout() {
            try {
                await fetch('/api/logout', { method: 'POST' });
            } catch (e) { }
            window.location.href = '/login.html';
        }

        // ==================== Audio Functions ====================
        // Mic streaming is automatic - just use the audio player controls

        function handleAudioData(audioBytes) {
            // Not used - audio is streamed via HTTP WAV
        }

        // Initial connection
        connect();
    </script>
</body>

</html>